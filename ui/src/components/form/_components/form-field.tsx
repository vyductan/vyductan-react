"use client";

import type { ControllerProps, FieldPath, FieldValues } from "react-hook-form";
import React, { cloneElement, isValidElement } from "react";

import { cn } from "@acme/ui/lib/utils";
import { FormField as ShadFormField } from "@acme/ui/shadcn/form";

import { useFormContext } from "../context";
import { useFieldOptionalityCheck } from "../hooks/use-field-optionality-check";
import { FormControl } from "./form-control";
import { FormItem } from "./form-item";
import { FieldLabel } from "./form-label";
import { FieldMessage } from "./form-message";

// type FormFieldContextValue<
//   TFieldValues extends FieldValues = FieldValues,
//   TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
// > = {
//   name: TName;
// };
// const FormFieldContext = React.createContext<FormFieldContextValue>(
//   {} as FormFieldContextValue,
// );

type FieldProps<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
  TTransformedValues = TFieldValues,
> = Omit<
  ControllerProps<TFieldValues, TName, TTransformedValues>,
  "render" | "name"
> & {
  ref?: React.ForwardedRef<HTMLDivElement>;
  name?: ControllerProps<TFieldValues, TName, TTransformedValues>["name"];
  label?: string | React.JSX.Element;
  description?: React.ReactNode;
  className?: string;
  /* The prompt message. If not provided, the prompt message will be generated by the validation rule. */
  help?:
    | React.ReactNode
    | ((
        ctx: Parameters<
          ControllerProps<TFieldValues, TName, TTransformedValues>["render"]
        >[0],
      ) => React.ReactNode);
  validateStatus?: "success" | "warning" | "error" | "validating";
  layout?: "horizontal" | "vertical";
  required?: boolean;

  /* Props of children node, for example, the prop of Switch or Checkbox is `checked`. This prop is an encapsulation of `getValueProps`, which will be invalid after customizing getValueProps */
  valuePropName?: string;

  /** Additional props with sub component (It's not recommended to generate dynamic function prop by `getValueProps`. Please pass it to child component directly) */
  getValueProps?: (value: any) => Record<string, any>;

  /** Normalize value from component value before passing to Form instance. Do not support async */
  normalize?: (value: any, prevValue: any) => any;

  children?:
    | React.ReactElement
    | ControllerProps<TFieldValues, TName, TTransformedValues>["render"];

  render?: ControllerProps<TFieldValues, TName, TTransformedValues>["render"];
};
const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
  TTransformedValues = TFieldValues,
>({
  control,
  name,

  children,
  render,

  label: labelProp,

  className,

  help,

  validateStatus,

  required: requiredProp,

  layout: layoutProp,

  normalize,

  getValueProps,
  valuePropName,

  ...props
}: FieldProps<TFieldValues, TName, TTransformedValues>) => {
  const form = useFormContext<TFieldValues, any, TFieldValues>();
  const layout = layoutProp ?? form?.layout;
  const classNames = form?.classNames;

  const optional = useFieldOptionalityCheck(name, form?.schema);
  const required = requiredProp ?? (optional === undefined ? false : !optional);

  // if (render && name) {
  //   return (
  //     <FormFieldContext.Provider value={{ name: name }}>
  //       <Controller name={name} render={render} {...props} />
  //     </FormFieldContext.Provider>
  //   );
  // }
  // if (form && name) {
  //   return (
  //     <FieldController
  //       control={form.control}
  //       name={name}
  //       children={children}
  //       onChange={onChange}
  //       required={isRequired}
  //       layout={layout}
  //       classNames={classNames}
  //       {...props}
  //     />
  //   );
  // }

  // Based on shadcn
  if (render && control && name) {
    return <ShadFormField control={control} name={name} render={render} />;
  }

  const label = labelProp && (
    <FieldLabel className={cn(classNames?.label)} required={required}>
      {labelProp}
    </FieldLabel>
  );

  const finalValuePropName = valuePropName ?? "value";

  if (
    !render &&
    form &&
    name &&
    isValidElement<{
      onBlur?: (event: any) => void;
      onChange?: (event: any) => void;
      [key: string]: any;
    }>(children)
  ) {
    return (
      <ShadFormField
        control={control}
        name={name}
        render={(ctx) => (
          <FormItem layout={layout} className={className} {...props}>
            {label}
            <div className="w-full" data-slot="form-item-control">
              <FormControl>
                {cloneElement(children, {
                  ...ctx.field,
                  [finalValuePropName]: ctx.field.value,
                  // Apply getValueProps if provided
                  ...(getValueProps ? getValueProps(ctx.field.value) : {}),
                  onBlur: (event: any) => {
                    children.props.onBlur?.(event);
                    ctx.field.onBlur();
                  },
                  onChange: (event: any) => {
                    const value = event === undefined ? null : event; // fix react-hook-form doesn't support undefined value

                    const normalizedValue = normalize?.(value, ctx.field.value);

                    ctx.field.onChange(
                      normalize
                        ? normalizedValue === undefined
                          ? null
                          : normalizedValue
                        : value,
                    );
                  },
                })}
              </FormControl>
              <FieldMessage
                validateStatus={
                  validateStatus ?? (help ? "default" : undefined)
                }
              >
                {typeof help === "function" ? help(ctx) : help}
              </FieldMessage>
            </div>
          </FormItem>
        )}
      />
    );
  }
  // if (nadme) {
  //   return (
  //     <FormFieldContext.Provider
  //       value={{
  //         name,
  //       }}
  //     >
  //       <FormItem {...props}>
  //         {ContentComp}
  //         {/* <FieldRender
  //           children={children}
  //           ref={ref}
  //           required={required}
  //           layout={layout}
  //           classNames={classNames}
  //           {...props}
  //         /> */}
  //       </FormItem>
  //     </FormFieldContext.Provider>
  //   );
  // }

  if (name && typeof children === "function") {
    return (
      <ShadFormField
        control={control}
        name={name}
        render={({ field, fieldState, formState }) => (
          <FormItem layout={layout} className={className} {...props}>
            {label}
            <div className="w-full" data-slot="form-item-control">
              <FormControl>
                {children({ field, fieldState, formState })}
                {/* {cloneElement(children, {
              ...field,
              // value: watchedValue,
              onBlur: (event) => {
                children.props.onBlur?.(event);
                field.onBlur();
              },
              onChange: (event: any) => {
                const value = event === undefined ? null : event; // fix react-hook-form doesn't support undefined value

                const normalizedValue = normalize?.(value, field.value);
                field.onChange(
                  normalize
                    ? normalizedValue === undefined
                      ? null
                      : normalizedValue
                    : value,
                );
              },
            })} */}
              </FormControl>
              <FieldMessage />
            </div>
          </FormItem>
        )}
      />
    );
  }

  // No control and name
  return (
    <FormItem
      layout={layout}
      className={cn(!label && "justify-end", className)}
      {...props}
    >
      {label}
      {typeof children === "function" ? (
        <>You should pass name into {"<Field>"}</>
      ) : (
        children
      )}
    </FormItem>
  );
};

// type FieldControllerProps<
//   TFieldValues extends FieldValues = FieldValues,
//   TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
// > = {
//   ref?: React.ForwardedRef<HTMLDivElement>;
//   control: Control<TFieldValues>;
//   name: TName;
//   children?:
//     | React.ReactElement<any>
//     | (({
//         field,
//         fieldState,
//         formState,
//       }: {
//         field: FieldControllerRenderProps<TFieldValues, TName>;
//         fieldState: ControllerFieldState;
//         formState: UseFormStateReturn<TFieldValues>;
//       }) => React.ReactElement<any>);
//   onChange?: (...event: any[]) => any;

//   disabled?: boolean;
//   required?: boolean;

//   layout?: "horizontal" | "vertical";
//   classNames?: {
//     label?: string;
//   };

//   className?: string;
// };
// const FieldController = <
//   TFieldValues extends FieldValues = FieldValues,
//   TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
// >({
//   ref,
//   control,
//   name,
//   onChange,
//   children,
//   disabled,
//   required,
//   layout,

//   className,
//   classNames,
//   ...props
// }: FieldControllerProps<TFieldValues, TName>) => {
//   const watchedValue = useWatch({
//     control,
//     name,
//   });

//   return (
//     <FormFieldContext.Provider
//       value={{
//         name,
//       }}
//     >
//       <Controller
//         control={control}
//         name={name}
//         disabled={disabled}
//         render={({ field, fieldState, formState }) => {
//           return (
//             <FormItem className={className} layout={layout}>
//               <FieldRender
//                 required={required}
//                 children={
//                   children
//                     ? typeof children === "function"
//                       ? children({
//                           field,
//                           fieldState,
//                           formState,
//                         })
//                       : React.cloneElement(
//                           children as React.ReactElement<{
//                             value?: any;
//                             onBlur?: (...event: any[]) => any;
//                             onChange?: (...event: any[]) => any;
//                           }>,
//                           {
//                             ...field,
//                             value: watchedValue,
//                             onBlur: (event: any) => {
//                               (
//                                 children.props as {
//                                   onBlur?: (...event: any[]) => any;
//                                 }
//                               ).onBlur?.(event);
//                               // field.onBlur(onChange ? onChange(event) : event);
//                               field.onBlur();
//                             },
//                             onChange: (event: any) => {
//                               (
//                                 children.props as {
//                                   onChange?: (...event: any[]) => any;
//                                 }
//                               ).onChange?.(event);
//                               field.onChange(
//                                 onChange ? onChange(event) : event,
//                               );
//                             },
//                           },
//                         )
//                     : undefined
//                 }
//                 ref={ref}
//                 classNames={classNames}
//                 {...props}
//               />
//             </FormItem>
//           );
//         }}
//       />
//     </FormFieldContext.Provider>
//   );
// };

// type FieldControllerRenderProps<
//   TFieldValues extends FieldValues = FieldValues,
//   TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
// > = ControllerRenderProps<TFieldValues, TName>;

export { FormField, FormField as Field };
export type { FieldProps };
